# [NoCubes](https://Cadiboo.github.io/projects/nocubes/)
![Build](https://github.com/Cadiboo/NoCubes/workflows/Build/badge.svg?branch=master)
[
![Curseforge Downloads](https://cf.way2muchnoise.eu/full_nocubes_downloads.svg)
![Curseforge Versions](https://cf.way2muchnoise.eu/versions/nocubes.svg)
](https://www.curseforge.com/minecraft/mc-mods/nocubes)
[
![Modrinth Downloads](https://modrinth-utils.vercel.app/api/badge/downloads?id=w3bbwFYU)
](https://modrinth.com/mod/nocubes)
[
![Discord](https://img.shields.io/discord/493715188843937793?label=Discord)
](https://discord.gg/NWzs34rqPB)  
A mod for 1.12.2+ by [Cadiboo](https://github.com/Cadiboo) that creates smooth terrain in Minecraft.  
[Website](https://Cadiboo.github.io/projects/nocubes/)  
[CurseForge Page](https://minecraft.curseforge.com/projects/nocubes)  
![NoCubes](https://cadiboo.github.io/projects/nocubes/sd-images/realistic.png "NoCubes")  

Note: NoCubes is not feature complete and is still very much in development.

## How (technical)
See also the project's [TODO list](TODO.md), [Trello board](https://trello.com/b/k1Rfd0aj/nocubes) and [TV Show](https://www.imdb.com/title/tt7876360)
#### Visuals
This feature works regardless of if the server has the mod installed or not.

Here's how Minecraft's rendering system works:
- Minecraft renders 16x16x16 block sized â€˜render chunksâ€™ of your world
- Building the visual data for the entire chunk each frame would be inefficient so the visual data is built once when the chunk is loaded and only rebuilt when it changes (i.e. a block in the chunk changes). The render data for each visible chunk is drawn to the screen every frame (but not recalculated each frame)
- To build this render data Minecraftâ€™s engine allocates some memory for this render data and then goes through (iterates) every block in the 16x16x16 area, gets the model for the block (which contains all the faces and textures to render), calculates light for the block, calculates colouring for the block and then puts this data for each face into the chunk render data it is building

Here's where NoCubes comes in:
- [NoCubes adds its own code in between the render data memory allocation and the block iteration](src/main/resources/nocubes-transformer.js). This code has access to the render data before any vanilla blocks have been rendered to it. NoCubes then uses the SurfaceNets smoothing algorithm to generate smooth faces for the blocks in the chunk. For each face it then finds the closest block, gets the model data for that block, gets the texture from that model data, calculates lighting, calculates coloring and puts that data into the render data (same thing as Minecraft does, except it uses the face position generated by the algorithm, not the model).
- [NoCubes adds its own code during the render engineâ€™s 16x16x16 iteration to stop the engine rendering blocks](src/main/java/io/github/cadiboo/nocubes/mixin/RenderChunkRebuildTaskMixin.java) that NoCubes has already rendered smooth

#### Collisions
This feature only works when both the client and server have NoCubes installed.

NoCubes changes Minecraft's terrain collisions to be smooth too (i.e. you can walk on the smooth terrain, rather than on the original cubes).

Here's how Minecraft's rendering system works:
- Whenever you walk on terrain, Minecraft looks at the nearby blocks
- For each block the engine gets its collision shape
- If the player is inside the shape, it pushes the player out

[NoCubes changes the shape that the collision system sees for each block](src/main/java/io/github/cadiboo/nocubes/mixin/BlockStateBaseMixin.java):
- For each nearby block, NoCubes redirects Minecraft's collision system's request for the block's collision shape to NoCubes' collision code
- NoCubes' collision code then runs the mesh generator (Surface Nets by default) on that block and the surrounding blocks to get a list of mesh faces
- It then turns each one of these mesh faces into shapes and gives them back to Minecraft's collision engine

This approach is wasteful because the mesh generator is being called for the same area multiple times rather than once for the whole nearby area. Work is being done to fix this.

### Meshing
Reading the above you might've started wondering "What is a mesh generator?".
Mesh generators (aka isosurface extractors) are the underlying technology that makes NoCubes work.
A mesh generator is an algorithm (NoCubes supports multiple different ones) that takes a field (aka area) of voxels (aka cubes/blocks) and turns them into faces (quads/squares or triangles).
Here are some links:
- [Video: What is isosurface extraction](https://youtu.be/6oMZb3yP_H8)
- [Interactive examples of isosurface extraction](https://wordsandbuttons.online/interactive_explanation_of_marching_cubes_and_dual_contouring.html)
- [Index of different isosurface extractors](https://swiftcoder.wordpress.com/planets/isosurface-extraction/)
- [Article: How voxel games similar to Minecraft render their terrain](https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/)
- [Video: UE5 Voxelize plugin](https://youtu.be/bvcBBa3X4js)
- [Wikipedia: Overview and list of common isosurface extractors](https://en.wikipedia.org/wiki/Isosurface#Implementation_algorithms)
- [Wikipedia: Marching Cubes, one of the original and simplest isosurface extractors](https://en.wikipedia.org/wiki/Marching_cubes)
- [Article: Surface Nets deep dive](https://bonsairobo.medium.com/smooth-voxel-mapping-a-technical-deep-dive-on-real-time-surface-nets-and-texturing-ef06d0f8ca14)
- [Post: Thread about Surface Nets](https://www.reddit.com/r/VoxelGameDev/comments/pklhuo/i_wish_i_found_surface_nets_sooner/)
- [Article: Handling seams in meshes](http://ngildea.blogspot.com/2014/09/dual-contouring-chunked-terrain.html)
- [GitHub: C++ dual marching cubes](https://github.com/dominikwodniok/dualmc)
- [Blog: Building a game with isosurface extraction](http://procworld.blogspot.com/search/label/Dual%20Contouring)
- [Paper: Constrained Elastic Surface Nets](https://www.merl.com/publications/docs/TR99-24.pdf)
- [GitHub: C# Surface Nets](https://github.com/TomaszFoster/NaiveSurfaceNets)

Isosurface extraction isn't the only way of procedurally generating a mesh though, Wave Function Collapse is another very interesting approach that gives artists much more control over the final product:
- [Video: Wave Function Collapse overview](https://youtu.be/20KHNA9jTsE)

## Setting up a development environment (using IntelliJ)
1. Clone/download this repo
1. Open NoCubes/build.gradle in IntelliJ and select 'Open as Gradle Project'
1. Go to the gradle sidebar on the right and click the ðŸ”„ "Reload All Gradle Projects" icon
1. Go to the run configurations dropdown in the right of the top 'sidebar' and select 'runClient'
1. Clicking the ðŸ•· "Debug 'runClient'" button will start Minecraft with NoCubes running

### OptiFine compatibility
OptiFine is a bit hard to work with  
To get it running in your development environment:  
1. Download the OptiFine version that you want from [optifine.net](https://optifine.net/downloads)  
2. Download OptiFine dev tweaker from [GitHub](https://github.com/OpenCubicChunks/OptiFineDevTweaker/releases/latest)  
3. Put both jar files into `NoCubes/run/mods/`  
4. Run the game and OptiFine & Shaders will load

To be able to also compile against OptiFine (do the above steps first):
1. You must have set up NoCubes and had gradle install and deobfuscate Minecraft first
2. Make sure that you have Minecraft for the version you're running NoCubes on  
     If you don't, just open the minecraft launcher, select the right version and hit 'Play'.
     The launcher will download everything and you can just quit the game when it starts.
     To find the version of Minecraft that NoCubes is being built against look in `gradle.properties`.
3. Download OptiFineDeobf from [GitHub](https://github.com/Cadiboo/OptiFineDeobf/releases/latest)
4. Run the OptiFine jar in `NoCubes/run/mods/` and select 'Extract', put the resulting extracted jar somewhere outside the `mods` folder
5. Run OptiFineDeobf, select the extracted OptiFine jar in `NoCubes/run/mods/` and select the `NoCubes` folder for the project folder
6. Select a mappings file that maps from SRG to MCP/official (don't use obf -> MCP mappings)
7. Select 'Make Public' and 'Forge Dev jar' then click 'Deobf'
8. Put the deobfuscated OptiFine jar into `NoCubes/libs/`
9. Refresh gradle in your IDE and you should be able to compile against OptiFine's classes (and running OptiFine still works as it did before)

Note: You can replace the normal OptiFine jar with the extracted (non-deobfuscated) one in `NoCubes/run/mods/` (this *may* speed up OptiFine's loading time)

NoCubes' OptiFine compatibility should not be shipped to production compiled directly against OptiFine's classes because
it can crash if OptiFine isn't present. Instead, the code should be converted to Reflection.  
Using Reflection has the added benefit of allowing the same NoCubes jar to support multiple versions of OptiFine.

<details>
  <summary>Other OptiFine info (just putting this here so I don't forget and can come back to it at some point)</summary>

  It's possible to get Forge to do most of the work by adding the following code to `build.gradle`.
  ```groovy
  repositories {
    flatDir {
      dirs 'run/mods'
    }
  }
  dependencies {
    // OptiFine is the first dependency because so that we can compile against its version of vanilla's classes, not Forge's
    // Needs a group classifier even though it's not used, this can be anything, I used 'undefined'
    compileOnly fg.deobf('undefined:OptiFine_1.16.5_HD_U_G8_pre12_MOD.jar:')
    
    //... other dependencies like Forge
  }
  ```
  However, this doesn't fully work because Forge doesn't apply my ATs to OptiFine's classes :(  
  It's probably possible to run [AccessTransformers](https://github.com/MinecraftForge/ForgeGradle/blob/6639464b29b0923187eee0a609e546ba9f1b998b/src/userdev/java/net/minecraftforge/gradle/userdev/tasks/AccessTransformJar.java#L45) ourselves against the deobfed OptiFine dependency, but I can't figure out how   
</details>
