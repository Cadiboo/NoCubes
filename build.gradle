buildscript {
	repositories {
		maven { url = 'https://maven.minecraftforge.net/' }
		mavenCentral()
	}
	dependencies {
		classpath 'net.minecraftforge.gradle:ForgeGradle:5.1.+'
	}
}
plugins {
	id 'wtf.gofancy.fancygradle' version '1.1.+'
}
apply plugin: 'net.minecraftforge.gradle'
//Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.
fancyGradle {
	patches {
		resources
		coremods
		asm
		mergetool
	}
}

// From https://github.com/MinecraftForge/MinecraftForge/blob/0579572148079a6bc483ff42404878962fc48702/build.gradle#L55
ext {
	NIGHTCONFIG_VERSION = '3.6.0'
}

def getGitCommit = { ->
	def stdout = new ByteArrayOutputStream()
	def result = exec {
		commandLine 'git', 'rev-parse', '--short', 'HEAD'
		standardOutput = stdout
	}
	return result.getExitValue() != 0 ? 'nogit' : stdout.toString().trim()
}
// We use the version format MCVERSION-MAJOR.MINOR.PATCH-COMMIT
version = "${modMinecraftVersion}-${modVersion}-${getGitCommit()}"
group = modGroup
archivesBaseName = modFileName

sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.

minecraft {
	// The mappings can be changed at any time, and must be in the following format.
	// snapshot_YYYYMMDD   Snapshot are built nightly.
	// stable_#            Stables are built at the discretion of the MCP team.
	// Use non-default mappings at your own risk. they may not always work.
	// Simply re-run your setup task after changing the mappings to update your workspace.
	//mappings channel: 'snapshot', version: '20171003-1.12'
	mappings channel: 'stable', version: '39-1.12'
	// makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

	 accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

	// Default run configurations.
	// These can be tweaked, removed, or duplicated as needed.
	runs {
		client {
			workingDirectory project.file('run/client')

			// Recommended logging data for a userdev environment
			property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

			// Recommended logging level for the console
			property 'forge.logging.console.level', 'debug'

			property 'fml.coreMods.load', coremodLoadingPlugin
		}

		server {
			workingDirectory project.file('run/server')

			// Recommended logging data for a used environment
			property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

			// Recommended logging level for the console
			property 'forge.logging.console.level', 'debug'

			property 'fml.coreMods.load', coremodLoadingPlugin
		}
	}
}

dependencies {
	// Specify the version of Minecraft to use, If this is any group other then 'net.minecraft' it is assumed
	// that the dep is a ForgeGradle 'patcher' dependency. And it's patches will be applied.
	// The userdev artifact is a special name and will get all sorts of transformations applied to it.
	minecraft "net.minecraftforge:forge:${modMinecraftVersion}-${modForgeVersion}"

	// You may put jars on which you depend on in ./libs or you may define them like so..
	// compile "some.group:artifact:version:classifier"
	// compile "some.group:artifact:version"

	// Real examples
	// compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // adds buildcraft to the dev env
	// compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // adds ejml to the dev env

	// The 'provided' configuration is for optional dependencies that exist at compile-time but might not at runtime.
	// provided 'com.mod-buildcraft:buildcraft:6.0.8:dev'

	// These dependencies get remapped to your current MCP mappings
	// deobf 'com.mod-buildcraft:buildcraft:6.0.8:dev'

//	deobfCompile "renderchunk-rebuildchunk-hooks:RenderChunk-rebuildChunk-Hooks:1.12.2:0.3.0"

	// for more info...
	// http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
	// http://www.gradle.org/docs/current/userguide/dependency_management.html

	// See https://github.com/MinecraftForge/MinecraftForge/blob/0579572148079a6bc483ff42404878962fc48702/build.gradle#L280-L281
	implementation "com.electronwill.night-config:core:${NIGHTCONFIG_VERSION}"
	implementation "com.electronwill.night-config:toml:${NIGHTCONFIG_VERSION}"

}

// Example for how to get properties into the manifest for reading by the runtime..
jar {
	manifest {
		attributes([
				"Specification-Title": "examplemod",
				"Specification-Vendor": "examplemodsareus",
				"Specification-Version": "1", // We are version 1 of ourselves
				"Implementation-Title": project.name,
				"Implementation-Version": "${version}",
				"Implementation-Vendor" :"examplemodsareus",
				"Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
		])
		if (project.hasProperty('core_plugin')) {
			attributes 'FMLCorePluginContainsFMLMod': 'true'
			attributes 'FMLCorePlugin': project.core_plugin
		}
		attributes 'FMLAT': 'nocubes_at.cfg'
		attributes 'ContainedDeps': "core-${NIGHTCONFIG_VERSION}.jar toml-${NIGHTCONFIG_VERSION}.jar"
	}
}

// Example configuration to allow publishing using the maven-publish task
// This is the preferred method to reobfuscate your jar file
jar.finalizedBy('reobfJar')

processResources {
	duplicatesStrategy = 'include'

	// this will ensure that this task is redone when the versions change.
	inputs.property "version", project.version
	inputs.property "mcversion", modMinecraftVersion

	// replace stuff in mcmod.info, nothing else
	from(sourceSets.main.resources.srcDirs) {
		include 'mcmod.info'

		// replace version and mcversion
		expand 'version': project.version, 'mcversion': modMinecraftVersion
	}

	// copy everything else except the mcmod.info
	from(sourceSets.main.resources.srcDirs) {
		exclude 'mcmod.info'
	}
}

// Sign all the jars
import net.minecraftforge.gradle.common.tasks.SignJar

task signJar(type: SignJar, dependsOn: reobf) {

	// Skips if the keyStore property is missing.
	onlyIf {
		project.hasProperty('keyStore')
	}

	// findProperty allows us to reference the property without it existing.
	// Using project.propName would cause the script to fail validation if the property did not exist.
	keyStore = project.findProperty('keyStore')
	alias = project.findProperty('keyStoreAlias')
	storePass = project.findProperty('keyStorePass')
	keyPass = project.findProperty('keyStoreKeyPass')
	inputFile = jar.archivePath
	outputFile = jar.archivePath

}

// Runs this task automatically when build is run.
build.dependsOn signJar
