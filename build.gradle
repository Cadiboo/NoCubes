// Forge buildscript - necessary for Forge to be setup
buildscript {
	repositories {
		// These repositories are only for Gradle plugins, put any other repositories in the repository block further below
		maven { url = 'https://maven.minecraftforge.net' }
		mavenCentral()
	}
	// Buildscript dependency on Forge Gradle
	dependencies {
		classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '5.1.+', changing: true
	}
}

plugins {
	// Shadow jar includes our libraries into our final jar
	id 'com.github.johnrengelman.shadow' version '7.0.0'
}

// Necessary for Forge to be setup
apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'eclipse'
apply plugin: 'maven-publish'
apply from: 'https://raw.githubusercontent.com/SizableShrimp/Forge-Class-Remapper/main/classremapper.gradle'

repositories {
	maven {
		url "https://www.cursemaven.com"
		content {
			includeGroup "curse.maven"
		}
	}
}

def getGitCommit = { ->
    def stdout = new ByteArrayOutputStream()
    def result = exec {
        commandLine 'git', 'rev-parse', '--short', 'HEAD'
        standardOutput = stdout
    }
    return result.getExitValue() != 0 ? 'nogit' : stdout.toString().trim()
}

// We use the version format MCVERSION-MAJOR.MINOR.PATCH-COMMIT
version = "${modMinecraftVersion}-${modVersion}-${getGitCommit()}"
group = modGroup
archivesBaseName = modFileName

if (System.getenv('BUILD_NUMBER') || System.getenv('TRAVIS_BUILD_NUMBER') || System.getenv('CIRCLE_BUILD_NUM'))
	version += '.' + System.getenv('BUILD_NUMBER') ?: System.getenv('TRAVIS_BUILD_NUMBER') ?: System.getenv('CIRCLE_BUILD_NUM') ?: '0'

// Mojang ships Java 16 to end users in 1.17+, so mods should target this version
java.toolchain.languageVersion = JavaLanguageVersion.of(16)
println('Java: ' + System.getProperty('java.version') + ' JVM: ' + System.getProperty('java.vm.version') + '(' + System.getProperty('java.vendor') + ') Arch: ' + System.getProperty('os.arch'))

minecraft {
	// See here for more info "https://github.com/MinecraftForge/MinecraftForge/blob/b6ce4fb066eb886a305f0678649c33d6f8ba4f76/mdk/build.gradle#L23-L33"
	mappings channel: 'official', version: modMinecraftVersion
	// makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

	// We have an access transformer because we reach into some of Minecraft's private/protected rendering internals
	accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg') // Currently, this location cannot be changed from the default.

	runs {
		client {
			workingDirectory project.file('run')
			jvmArg '-ea' // Enable assertions
			// The markers can be added/removed as needed (separated by commas)
			property 'forge.logging.markers', 'XFORM'
//			property 'forge.logging.markers', 'XFORM,MODLAUNCHER,CLASSDUMP' // For ASM classdump
			property 'forge.logging.console.level', 'debug'
//			property 'forge.logging.console.level', 'trace' // For ASM classdump
			property 'mixin.env.disableRefMap', 'true' // To allow BetterFoliage to load

			mods {
				nocubes {
					// Main sources (everything that goes in your final compiled mod. From /src/main/)
					source sourceSets.main
					// Test sources (debugging, unit tests. From /src/test/)
					source sourceSets.test
				}
			}
		}

		server {
			workingDirectory project.file('run/server')
			jvmArg '-ea' // Enable assertions
			// The markers can be added/removed as needed (separated by commas)
			property 'forge.logging.markers', 'XFORM'
			property 'forge.logging.console.level', 'debug'

			mods {
				nocubes {
					// Main sources (everything that goes in your final compiled mod. From /src/main/)
					source sourceSets.main
					// Test sources (debugging, unit tests. From /src/test/)
					source sourceSets.test
				}
			}
			property 'nocubes.testing.integration', 'true'
			setForceExit(false)
		}
	}
}

dependencies {
	// If OptiFine (deobfuscated with Cadiboo's OptiFine deobf tool) is in libs, we want to be able to compile against its classes
	// We use 'provided' and not 'implementation', we don't want it to actually load at runtime because the non-deobf
	// version of OptiFine and OptiFineDevTweaker are loaded from the mods folder at runtime
	// OptiFine is the first dependency because so that we can compile against its version of vanilla's classes, not Forge's
	compileOnly fileTree(include: ['OptiFine_*_MOD-deobf.jar'], dir: 'libs')

	// Specify the version of Minecraft to use
	// If this is any group other than 'net.minecraft' it is assumed that the dep is a ForgeGradle 'patcher' dependency and its patches will be applied
	// The userdev artifact is a special name and will get all sorts of transformations applied to it
	minecraft "net.minecraftforge:forge:${modMinecraftVersion}-${modForgeVersion}"

	// Add a compile/implementation dependency on all .jar files in ./libs
	implementation fileTree(include: ['*.jar'], exclude: ['OptiFine_*_MOD-deobf.jar'], dir: 'libs')

	// For the config color picker (we include it in our production jar with ShadowJar)
	shadow implementation('org.beryx:awt-color-factory:1.0.2')

//	implementation fg.deobf("curse.maven:KotlinForForge-351264:3331341")
//	implementation fg.deobf("curse.maven:BetterFoliage-228529:3335091")

	// For unit tests
	testImplementation 'org.mockito:mockito-core:3.11.2'
	testImplementation 'junit:junit:4.13'
}

jar {
	classifier 'dev'
	manifest {
		attributes([
			'Specification-Title'     : modId,
			'Specification-Vendor'    : modGroup,
			'Specification-Version'   : '1.0', // We are version 1 of ourselves
			'Implementation-Title'    : project.name,
			'Implementation-Version'  : project.version,
			'Implementation-Vendor'   : modGroup,
			'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
			'Signing-Fingerprint'     : project.hasProperty('signSHA1') ? project.findProperty('signSHA1') : 'unsigned',
			'Built-On-Java'           : "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
			'Built-For'               : "${project.modMinecraftVersion}-${project.modForgeVersion}"
		])
	}
}
shadowJar {
	classifier ''

	configurations = [project.configurations.shadow]
	relocate('org.beryx', 'io.github.cadiboo.nocubes.repackage.org.beryx')

	// We have a modified version of minecraft's BlockState class with our ASM fields added that we compile against
	// We remove it from the final jar though (we don't want it interfering with anything at runtime)
	exclude '**/net/minecraft/**'

	manifest.attributes(jar.manifest.getAttributes())
}
reobf {
	// We want the output of the following tasks to be reobfuscated
	// More info at "https://github.com/MinecraftForge/MinecraftForge/blob/b6ce4fb066eb886a305f0678649c33d6f8ba4f76/mdk/build.gradle#L157-L161"
	shadowJar {}
}
task sourcesJar(type: Jar, dependsOn: classes) {
	archiveClassifier.set('sources')
	from sourceSets.main.allSource
}
task javadocJar(type: Jar, dependsOn: javadoc) {
	archiveClassifier.set('javadoc')
	from javadoc.destinationDir
}

artifacts {
	archives jar
	archives shadowJar
	archives sourcesJar
	archives javadocJar
}

// Sign all the jars
import net.minecraftforge.gradle.common.tasks.SignJar
[
	jar,
	shadowJar,
	sourcesJar,
	javadocJar,
].each {jarTask ->
	Task signingTask = tasks.create(name: "sign-${jarTask.name}", type: SignJar, dependsOn: jarTask) {
		// Skips if the keyStore property is missing.
		onlyIf {
			project.hasProperty('keyStore')
		}
		// findProperty allows us to reference the property without it existing.
		// Using project.propName would cause the script to fail validation if the property did not exist.
		keyStore = project.findProperty('keyStore')
		alias = project.findProperty('keyStoreAlias')
		storePass = project.findProperty('keyStorePass')
		keyPass = project.findProperty('keyStoreKeyPass')
		inputFile = jarTask.archiveFile
		outputFile = jarTask.archiveFile
	}
	jarTask.finalizedBy(signingTask)
}
