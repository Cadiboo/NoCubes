plugins {
	id 'java'
	id 'wtf.gofancy.fancygradle' version '1.1.+'
	// Shadow jar includes our libraries into our final jar
	id 'com.github.johnrengelman.shadow' version '7.0.0'
	id 'maven-publish'
	id 'net.minecraftforge.gradle' version '6.0.+'
}
fancyGradle {
	patches {
		resources
		coremods
		asm
		mergetool
	}
}

def getGitCommit = { ->
	def stdout = new ByteArrayOutputStream()
	def result = exec {
		commandLine 'git', 'rev-parse', '--short', 'HEAD'
		standardOutput = stdout
	}
	return result.getExitValue() != 0 ? 'nogit' : stdout.toString().trim()
}
// We use the version format MCVERSION-MAJOR.MINOR.PATCH-COMMIT
version = "${modMinecraftVersion}-${modVersion}-${getGitCommit()}"
group = modGroup
archivesBaseName = modFileName

sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.

minecraft {
	// The mappings can be changed at any time, and must be in the following format.
	// snapshot_YYYYMMDD   Snapshot are built nightly.
	// stable_#            Stables are built at the discretion of the MCP team.
	// Use non-default mappings at your own risk. they may not always work.
	// Simply re-run your setup task after changing the mappings to update your workspace.
	//mappings channel: 'snapshot', version: '20171003-1.12'
	mappings channel: 'stable', version: '39-1.12'
	// makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

	 accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

	// Default run configurations.
	// These can be tweaked, removed, or duplicated as needed.
	runs {
		client {
			workingDirectory project.file('run/client')

			// Recommended logging data for a userdev environment
			property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

			// Recommended logging level for the console
			property 'forge.logging.console.level', 'debug'

			property 'fml.coreMods.load', coremodLoadingPlugin
		}

		server {
			workingDirectory project.file('run/server')

			// Recommended logging data for a used environment
			property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

			// Recommended logging level for the console
			property 'forge.logging.console.level', 'debug'

			property 'fml.coreMods.load', coremodLoadingPlugin
		}
	}
}

configurations {
	library
	implementation.extendsFrom library
	shadow.extendsFrom library
}

repositories {
	maven {
		url "https://www.cursemaven.com"
		content {
			includeGroup "curse.maven"
		}
	}
	mavenCentral()
	// Mod jar dependencies in ./libs
	flatDir {
		dir 'libs'
	}
}
dependencies {
	// Specify the version of Minecraft to use, If this is any group other then 'net.minecraft' it is assumed
	// that the dep is a ForgeGradle 'patcher' dependency. And it's patches will be applied.
	// The userdev artifact is a special name and will get all sorts of transformations applied to it.
	minecraft "net.minecraftforge:forge:${modMinecraftVersion}-${modForgeVersion}"

	// You may put jars on which you depend on in ./libs or you may define them like so..
	// compile "some.group:artifact:version:classifier"
	// compile "some.group:artifact:version"

	// Real examples
	// compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // adds buildcraft to the dev env
	// compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // adds ejml to the dev env

	// The 'provided' configuration is for optional dependencies that exist at compile-time but might not at runtime.
	// provided 'com.mod-buildcraft:buildcraft:6.0.8:dev'

	// These dependencies get remapped to your current MCP mappings
	// deobf 'com.mod-buildcraft:buildcraft:6.0.8:dev'

//	deobfCompile "renderchunk-rebuildchunk-hooks:RenderChunk-rebuildChunk-Hooks:1.12.2:0.3.0"

	// for more info...
	// http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
	// http://www.gradle.org/docs/current/userguide/dependency_management.html

	// For the config color picker (we include it in our production jar with ShadowJar)
	library 'org.beryx:awt-color-factory:1.0.2'

	// From https://github.com/MinecraftForge/MinecraftForge/blob/0579572148079a6bc483ff42404878962fc48702/build.gradle#L55
	def NIGHTCONFIG_VERSION = '3.6.0'
	// See https://github.com/MinecraftForge/MinecraftForge/blob/0579572148079a6bc483ff42404878962fc48702/build.gradle#L280-L281
	library "com.electronwill.night-config:core:${NIGHTCONFIG_VERSION}"
	library "com.electronwill.night-config:toml:${NIGHTCONFIG_VERSION}"

}

// region build
tasks.withType(JavaCompile).configureEach {
	options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

processResources {
	duplicatesStrategy = 'include'

	// this will ensure that this task is redone when the versions change.
	inputs.property "version", project.version
	inputs.property "mcversion", modMinecraftVersion

	// replace stuff in mcmod.info, nothing else
	from(sourceSets.main.resources.srcDirs) {
		include 'mcmod.info'

		// replace version and mcversion
		expand 'version': project.version, 'mcversion': modMinecraftVersion
	}

	// copy everything else except the mcmod.info
	from(sourceSets.main.resources.srcDirs) {
		exclude 'mcmod.info'
	}
}

// Example for how to get properties into the manifest for reading by the runtime..
jar {
	archiveClassifier.set('dev')
	manifest {
		attributes([
				"Specification-Title": "examplemod",
				"Specification-Vendor": "examplemodsareus",
				"Specification-Version": "1", // We are version 1 of ourselves
				"Implementation-Title": project.name,
				"Implementation-Version": "${version}",
				"Implementation-Vendor" :"examplemodsareus",
				"Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
		])
		attributes 'FMLCorePluginContainsFMLMod': 'true'
		attributes 'FMLCorePlugin': coremodLoadingPlugin
		attributes 'FMLAT': 'accesstransformer.cfg'
	}
}
shadowJar {
	archiveClassifier.set('')

	configurations = [project.configurations.shadow]
	relocate('org.beryx', 'io.github.cadiboo.nocubes.repackage.org.beryx')
	relocate('com.electronwill.nightconfig.core', 'io.github.cadiboo.nocubes.repackage.com.electronwill.nightconfig.core')
	relocate('com.electronwill.nightconfig.toml', 'io.github.cadiboo.nocubes.repackage.com.electronwill.nightconfig.toml')
	manifest.attributes(jar.manifest.getAttributes())
}
reobf {
	// We want the output of the following tasks to be reobfuscated
	// More info at "https://github.com/MinecraftForge/MinecraftForge/blob/b6ce4fb066eb886a305f0678649c33d6f8ba4f76/mdk/build.gradle#L157-L161"
	shadowJar {}
}
task sourcesJar(type: Jar, dependsOn: classes) {
	archiveClassifier.set('sources')
	from sourceSets.main.allSource
}
//task javadocJar(type: Jar, dependsOn: javadoc) {
//	archiveClassifier.set('javadoc')
//	from javadoc.destinationDir
//}
//javadoc {
//	// Gradle doesn't support Java 8's new tags out of the box
//	options.tags = [
//			'apiNote:a:API Note:',
//			'implSpec:a:Implementation Requirements:',
//			'implNote:a:Implementation Note:',
//	]
//}

artifacts {
	archives jar
	archives shadowJar
	archives sourcesJar
//	archives javadocJar
}
// endregion

// region publish
// TODO: Move this to the publish step, not the build step
// Sign all the jars
import net.minecraftforge.gradle.common.tasks.SignJar

[
		jar,
		shadowJar,
		sourcesJar,
//		javadocJar,
].each { jarTask ->
	Task signingTask = tasks.create(name: "sign-${jarTask.name}", type: SignJar, dependsOn: jarTask) {
		// Skips if the keyStore property is missing.
		onlyIf {
			project.hasProperty('keyStore')
		}
		// findProperty allows us to reference the property without it existing.
		// Using project.propName would cause the script to fail validation if the property did not exist.
		keyStore = project.findProperty('keyStore')
		alias = project.findProperty('keyStoreAlias')
		storePass = project.findProperty('keyStorePass')
		keyPass = project.findProperty('keyStoreKeyPass')
		inputFile = jarTask.archiveFile
		outputFile = jarTask.archiveFile
	}
	jarTask.finalizedBy(signingTask)
}
// endregion
