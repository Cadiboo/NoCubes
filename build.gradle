plugins {
	id 'java'
	// Shadow jar includes our libraries into our final jar
	id 'com.github.johnrengelman.shadow' version '7.0.0'
	id 'maven-publish'
	id 'net.neoforged.gradle.userdev' version '7.0.97'
}

String execCmd(List<String> params, String fallback) {
	def stdout = new ByteArrayOutputStream()
	def result = exec {
		commandLine params
		standardOutput = stdout
	}
	return result.getExitValue() != 0 ? fallback : stdout.toString().trim()
}

// We use the version format MCVERSION-MAJOR.MINOR.PATCH-COMMIT
version = "${minecraft_version}-${mod_version}-${execCmd(['git', 'rev-parse', '--short', 'HEAD'], 'nogit')}"
group = mod_group
base {
	archivesName = mod_name
}

// Mojang ships Java 17 to end users in 1.18+, so mods should target this version
java.toolchain.languageVersion = JavaLanguageVersion.of(17)

repositories {
	maven {
		url "https://www.cursemaven.com"
		content {
			includeGroup "curse.maven"
		}
	}
	mavenCentral()
	// Mod jar dependencies in ./libs
	flatDir {
		dir 'libs'
	}
}

configurations {
	library
	implementation.extendsFrom library
	shadow.extendsFrom library
}
runs.configureEach {
	dependencies {
		runtime project.configurations.library
	}
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
idea {
	module {
		downloadSources = true
		downloadJavadoc = true
	}
}

dependencies {
	implementation "net.neoforged:neoforge:${neoforge_version}"
//	implementation "net.minecraft:neoform_client:${neoforge_version}"
//	implementation "net.minecraft:neoform_server:${neoforge_version}"

	// For @Nullable
	compileOnly 'org.jetbrains:annotations:23.0.0'

	// For the config color picker (we include it in our production jar with ShadowJar)
	library 'org.beryx:awt-color-factory:1.0.2'

	implementation 'curse.maven:Embeddium-908741:5265345' // embeddium-0.3.14+mc1.20.4.jar
//	implementation 'curse.maven:Oculus-581495:5108615' // oculus-mc1.20.1-1.6.15a.jar
//	implementation 'curse.maven:DistantHorizons-508933:4924664' // DistantHorizons-2.0.1-a-1.20.1.jar

	// For unit tests
	testImplementation 'org.mockito:mockito-core:4.5.1'
	testImplementation 'junit:junit:4.13.2'
}

runs {
	client {
	}
	server {
	}
	// Runs all integration tests then quits, for use in CI
	gameTestServer {
	}
	configureEach {
		workingDirectory project.file('run/' + it.name) as File
		def dumpTransformedClasses = false // Set to true to debug Mixin/Asm issues
		// The markers can be added/removed as needed (separated by commas)
		systemProperty 'forge.logging.markers', (!dumpTransformedClasses ? 'XFORM' : 'XFORM,MODLAUNCHER,CLASSDUMP')
		systemProperty 'forge.logging.console.level', (!dumpTransformedClasses ? 'debug' : 'trace')
		systemProperty 'mixin.debug.export', "${dumpTransformedClasses}"
		systemProperty 'forge.enabledGameTestNamespaces', mod_id // Run our integration tests

		modSource project.sourceSets.main
		modSource project.sourceSets.test

//		jvmArg '-ea' // Enable assertions
//		// Use the 'test' module (and both source sets) because it contains our integration tests
//		ideaModule "${project.name}.test"
//		mods.register(modId as String) {
//			sources = [sourceSets.main as SourceSet, sourceSets.test as SourceSet]
//		}
	}
}

// region build
tasks.withType(JavaCompile).configureEach {
	options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

tasks.withType(ProcessResources).configureEach {
	var replaceProperties = [
		mod_id                  : mod_id,
		mod_name                : mod_name,
		mod_version             : mod_version,
		minecraft_version       : minecraft_version,
		minecraft_version_range : minecraft_version_range,
		fml_loader_version_range: fml_loader_version_range,
		neoforge_version        : neoforge_version,
		neoforge_version_range  : neoforge_version_range,
	]
	inputs.properties replaceProperties

	filesMatching(['META-INF/mods.toml']) {
		expand replaceProperties
	}
}

jar {
	archiveClassifier.set('dev')
	manifest {
		attributes([
			// See https://docs.oracle.com/javase/8/docs/technotes/guides/versioning/spec/versioning2.html
			'Specification-Title'   : project.name,
			'Specification-Version' : mod_version,
			'Specification-Vendor'  : project.group,
			'Implementation-Title'  : mod_id,
			'Implementation-Version': project.version,
			'Implementation-Vendor' : project.group,

			'Built-For'             : "${minecraft_version}-${neoforge_version}",
			'Built-At-UTC'          : new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
			'Built-On-JVM'          : "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
			'Signing-Fingerprint'   : project.hasProperty('signSHA1') ? project.findProperty('signSHA1') : 'unsigned',

			'Main-Class'            : 'io.github.cadiboo.nocubes.DoNotRunThisFromTheConsoleDialog'
		])
	}
	from('LICENSE') {
		rename { "${it}_${project.base.archivesName.get()}" }
	}
}
shadowJar {
	archiveClassifier.set('')

	configurations = [project.configurations.shadow]
	[
		'org.beryx',
		'com.llamalad7.mixinextras',
	].each {
		relocate(it, "${mod_group}.repackage.${it}")
	}
	mergeServiceFiles() // Very important for MixinExtras to work
	manifest.attributes(jar.manifest.getAttributes())
	from('LICENSE') {
		rename { "${it}_${project.base.archivesName.get()}" }
	}
}
task sourcesJar(type: Jar, dependsOn: classes) {
	archiveClassifier.set('sources')
	from sourceSets.main.allSource
}
task javadocJar(type: Jar, dependsOn: javadoc) {
	archiveClassifier.set('javadoc')
	from javadoc.destinationDir
}
javadoc {
	// Gradle doesn't support Java 8's new tags out of the box
	options.tags = [
		'apiNote:a:API Note:',
		'implSpec:a:Implementation Requirements:',
		'implNote:a:Implementation Note:',
	]
}

artifacts {
	archives jar
	archives shadowJar
	archives sourcesJar
	archives javadocJar
}
// endregion

// region publish
//// TODO: Move this to the publish step, not the build step
//// Sign all the jars
//import net.neoforged.gradle.common.tasks.PotentiallySignJar
////import net.minecraftforge.gradle.common.tasks.SignJar
//
//[
//	jar,
//	shadowJar,
//	sourcesJar,
//	javadocJar,
//].each { jarTask ->
//	Task signingTask = tasks.create(name: "sign-${jarTask.name}", type: PotentiallySignJar, dependsOn: jarTask) {
//		// Skips if the keyStore property is missing.
//		onlyIf {
//			project.hasProperty('keyStore')
//		}
//		// findProperty allows us to reference the property without it existing.
//		// Using project.propName would cause the script to fail validation if the property did not exist.
//		keyStore = project.findProperty('keyStore')
//		alias = project.findProperty('keyStoreAlias')
//		storePass = project.findProperty('keyStorePass')
//		keyPass = project.findProperty('keyStoreKeyPass')
//		input = jarTask.archiveFile
//	}
//	jarTask.finalizedBy(signingTask)
//}
// endregion
