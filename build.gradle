// Forge buildscript - necessary for Forge to be setup
buildscript {
	repositories {
		// These repositories are only for Gradle plugins, put any other repositories in the repository block further below
		maven { url = 'https://maven.minecraftforge.net' }
		maven { url = 'https://repo.spongepowered.org/maven' }
		mavenCentral()
	}
	// Buildscript dependency on Forge Gradle
	dependencies {
		classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '5.1.+', changing: true
		classpath 'org.spongepowered:mixingradle:0.7-SNAPSHOT'
	}
}

plugins {
	id 'java'
	// Shadow jar includes our libraries into our final jar
	id 'com.github.johnrengelman.shadow' version '7.0.0'
	id 'eclipse'
	id 'maven-publish'
}

// Necessary for Forge to be setup
apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'org.spongepowered.mixin'

repositories {
	maven {
		url "https://www.cursemaven.com"
		content {
			includeGroup "curse.maven"
		}
	}
	mavenCentral()
}

def getGitCommit = { ->
	def stdout = new ByteArrayOutputStream()
	def result = exec {
		commandLine 'git', 'rev-parse', '--short', 'HEAD'
		standardOutput = stdout
	}
	return result.getExitValue() != 0 ? 'nogit' : stdout.toString().trim()
}

// We use the version format MCVERSION-MAJOR.MINOR.PATCH-COMMIT
version = "${modMinecraftVersion}-${modVersion}-${getGitCommit()}"
group = modGroup
archivesBaseName = modFileName

if (System.getenv('BUILD_NUMBER') || System.getenv('TRAVIS_BUILD_NUMBER') || System.getenv('CIRCLE_BUILD_NUM'))
	version += '.' + System.getenv('BUILD_NUMBER') ?: System.getenv('TRAVIS_BUILD_NUMBER') ?: System.getenv('CIRCLE_BUILD_NUM') ?: '0'

// Mojang ships Java 8 to end users in 1.16, so mods should target this version
java.toolchain.languageVersion = JavaLanguageVersion.of(8)
println "Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}"

minecraft {
	// See here for more info "https://github.com/MinecraftForge/MinecraftForge/blob/master/mdk/build.gradle#L28-L40"
	mappings channel: 'official', version: modMinecraftVersion
	// makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

	// We have an access transformer because we reach into some of Minecraft's private/protected rendering internals
	accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')
	// Currently, this location cannot be changed from the default.

	runs {
		client {
			workingDirectory project.file('run')
		}
		server {
			workingDirectory project.file('run/server')
			setForceExit(false)  // To allow integration tests to run in CI
		}
		configureEach {
			workingDirectory project.file('run/' + it.name) as File
			// The markers can be added/removed as needed (separated by commas)
			property 'forge.logging.markers', 'XFORM' // 'XFORM,MODLAUNCHER,CLASSDUMP' // For ASM classdump
			property 'forge.logging.console.level', 'debug' // 'trace' // For ASM classdump
			jvmArg '-ea' // Enable assertions
			// Use the 'test' module (and both source sets) because it contains our integration tests
			ideaModule "${project.name}.test"
			mods.register(modId as String) {
				sources = [sourceSets.main as SourceSet, sourceSets.test as SourceSet]
			}
		}
	}
}

mixin {
	add sourceSets.main, "mixins.${modId}.refmap.json"
	config "mixins.${modId}.json"

	debug.verbose = true
	debug.export = true
}

configurations {
	library
	implementation.extendsFrom library
	shadow.extendsFrom library
}
minecraft.runs.all {
	lazyToken('minecraft_classpath') {
		configurations.library.copyRecursive().resolve().collect { it.absolutePath }.join(File.pathSeparator)
	}
}

dependencies {
	// If OptiFine (deobfuscated with Cadiboo's OptiFine deobf tool) is in libs, we want to be able to compile against its classes
	// We use 'provided' and not 'implementation', we don't want it to actually load at runtime because the non-deobf
	// version of OptiFine and OptiFineDevTweaker are loaded from the mods folder at runtime
	// OptiFine is the first dependency because so that we can compile against its version of vanilla's classes, not Forge's
	compileOnly fileTree(include: ['OptiFine_*_MOD-deobf.jar'], dir: 'libs')

	// Specify the version of Minecraft to use
	// If this is any group other than 'net.minecraft' it is assumed that the dep is a ForgeGradle 'patcher' dependency and its patches will be applied
	// The userdev artifact is a special name and will get all sorts of transformations applied to it
	minecraft "net.minecraftforge:forge:${modMinecraftVersion}-${modForgeVersion}"

	// Apply Mixin AP
	annotationProcessor 'org.spongepowered:mixin:0.8.5:processor'

	// Add a compile/implementation dependency on all .jar files in ./libs
	implementation fileTree(include: ['*.jar'], exclude: ['OptiFine_*_MOD-deobf.jar'], dir: 'libs')

	// For the config color picker (we include it in our production jar with ShadowJar)
	library 'org.beryx:awt-color-factory:1.0.2'

//	implementation fg.deobf("curse.maven:KotlinForForge-351264:3331341")
//	implementation fg.deobf("curse.maven:BetterFoliage-228529:3335091")

	// For unit tests
	testImplementation 'org.mockito:mockito-core:4.2.0'
	testImplementation 'junit:junit:4.13.2'
}

jar {
	classifier 'dev'
	manifest {
		attributes([
			// See https://docs.oracle.com/javase/8/docs/technotes/guides/versioning/spec/versioning2.html
			'Specification-Title'   : project.name,
			'Specification-Version' : modVersion,
			'Specification-Vendor'  : project.group,
			'Implementation-Title'  : modId,
			'Implementation-Version': project.version,
			'Implementation-Vendor' : project.group,

			'Built-For'             : "${project.modMinecraftVersion}-${project.modForgeVersion}",
			'Built-At-UTC'          : new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
			'Built-On-JVM'          : "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
			'Signing-Fingerprint'   : project.hasProperty('signSHA1') ? project.findProperty('signSHA1') : 'unsigned',
		])
	}
}
shadowJar {
	classifier ''

	configurations = [project.configurations.shadow]
	relocate('org.beryx', 'io.github.cadiboo.nocubes.repackage.org.beryx')

	// We have a modified version of minecraft's BlockState class with our ASM fields added that we compile against
	// We remove it from the final jar though (we don't want it interfering with anything at runtime)
	exclude '**/net/minecraft/**'

	manifest.attributes(jar.manifest.getAttributes())
}
reobf {
	// We want the output of the following tasks to be reobfuscated
	// More info at "https://github.com/MinecraftForge/MinecraftForge/blob/b6ce4fb066eb886a305f0678649c33d6f8ba4f76/mdk/build.gradle#L157-L161"
	shadowJar {}
}
task sourcesJar(type: Jar, dependsOn: classes) {
	archiveClassifier.set('sources')
	from sourceSets.main.allSource
}
task javadocJar(type: Jar, dependsOn: javadoc) {
	archiveClassifier.set('javadoc')
	from javadoc.destinationDir
}
javadoc {
	// Gradle doesn't support Java 8's new tags out of the box
	options.tags = [
		'apiNote:a:API Note:',
		'implSpec:a:Implementation Requirements:',
		'implNote:a:Implementation Note:',
	]
}

artifacts {
	archives jar
	archives shadowJar
	archives sourcesJar
	archives javadocJar
}

// Sign all the jars
import net.minecraftforge.gradle.common.tasks.SignJar

[
	jar,
	shadowJar,
	sourcesJar,
	javadocJar,
].each { jarTask ->
	Task signingTask = tasks.create(name: "sign-${jarTask.name}", type: SignJar, dependsOn: jarTask) {
		// Skips if the keyStore property is missing.
		onlyIf {
			project.hasProperty('keyStore')
		}
		// findProperty allows us to reference the property without it existing.
		// Using project.propName would cause the script to fail validation if the property did not exist.
		keyStore = project.findProperty('keyStore')
		alias = project.findProperty('keyStoreAlias')
		storePass = project.findProperty('keyStorePass')
		keyPass = project.findProperty('keyStoreKeyPass')
		inputFile = jarTask.archiveFile
		outputFile = jarTask.archiveFile
	}
	jarTask.finalizedBy(signingTask)
}
